//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1008
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class ResManager
{
	public const int GRID_FLOOR = 0;
	public const int GRID_BLOCK = 1;
	public const int GRID_BLOCK_SIDE_LEFT = 2;
	public const int GRID_BLOCK_SIDE_RIGHT = 3;
	public const int GRID_BLOCK_NARROW = 4;
	public const int GRID_HEAD = 5;
	public const int GRID_BODY = 6;
	public const int GRID_TURN = 7;
	public const int GRID_TURN_PROGRESS = 8;
	public const int GRID_TO_SMALL = 9;
	public const int GRID_TO_SMALL_INVERT = 10;
	public const int GRID_TO_SIDE_LEFT = 11;
	public const int GRID_TO_SIDE_LEFT_INVERT = 12;
	public const int GRID_TO_SIDE_RIGHT = 13;
	public const int GRID_TO_SIDE_RIGHT_INVERT = 14;
	public const int GRID_TYPE_NUM = 15;

	public const int DECAL_HIT = 0;
	public const int DECAL_TYPE_NUM = 1;


	static public Mesh[] m_gridMesh = new Mesh[GRID_TYPE_NUM];
	static public Material[] m_gridMaterial = new Material[GRID_TYPE_NUM];
	static public Mesh m_decalMesh;
	static public Material[] m_decalMaterial = new Material[DECAL_TYPE_NUM];
	static public Mesh m_gridDarkBlockMesh;

	static List<GameObject> m_freeObjects = new List<GameObject>();

	public static void Init()
	{
		m_gridMesh[GRID_FLOOR] = CreateGridFloorMesh();
		m_gridMesh[GRID_BLOCK] = CreateGridBlockMesh1();
		m_gridMesh[GRID_BLOCK_SIDE_LEFT] = CreateGridBlockMeshSplit(true);
		m_gridMesh[GRID_BLOCK_SIDE_RIGHT] = CreateGridBlockMeshSplit(false);
		m_gridMesh[GRID_BLOCK_NARROW] = CreateGridBlockMeshNarrow();
		m_gridMesh[GRID_HEAD] = CreateSnakeHeadMesh();
		m_gridMesh[GRID_BODY] = CreateSnakeBodyMesh();
		m_gridMesh[GRID_TURN] = CreateSnakeTurnMesh();
		m_gridMesh[GRID_TURN_PROGRESS] = CreateSnakeTurnProgressMesh();
		m_gridMesh[GRID_TO_SMALL] = CreateSnakeZoomMesh(false);
		m_gridMesh[GRID_TO_SMALL_INVERT] = CreateSnakeZoomMesh(true);
		m_gridMesh[GRID_TO_SIDE_LEFT] = CreateSnakeSplitMesh(false, true);
		m_gridMesh[GRID_TO_SIDE_LEFT_INVERT] = CreateSnakeSplitMesh(true, true);
		m_gridMesh[GRID_TO_SIDE_RIGHT] = CreateSnakeSplitMesh(false, false);
		m_gridMesh[GRID_TO_SIDE_RIGHT_INVERT] = CreateSnakeSplitMesh(true, false);

		m_gridDarkBlockMesh = CreateGridBlockMeshDark();

		m_gridMaterial[GRID_FLOOR] = Resources.Load<Material> ("materials/Grid");
		m_gridMaterial[GRID_BLOCK] = m_gridMaterial[GRID_FLOOR];
		m_gridMaterial[GRID_BLOCK_SIDE_LEFT] = Resources.Load<Material> ("materials/Grid");
		m_gridMaterial[GRID_BLOCK_SIDE_RIGHT] = Resources.Load<Material> ("materials/Grid");
		m_gridMaterial[GRID_BLOCK_NARROW] = m_gridMaterial[GRID_BLOCK_SIDE_LEFT];
		m_gridMaterial[GRID_HEAD] = Resources.Load<Material> ("materials/Snake");
		m_gridMaterial[GRID_BODY] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TURN] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TURN_PROGRESS] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SMALL] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SMALL_INVERT] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SIDE_LEFT] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SIDE_LEFT_INVERT] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SIDE_RIGHT] = m_gridMaterial[GRID_HEAD];
		m_gridMaterial[GRID_TO_SIDE_RIGHT_INVERT] = m_gridMaterial[GRID_HEAD];


		m_decalMesh = CreateDecalMesh();
		m_decalMaterial[DECAL_HIT] = Resources.Load<Material> ("materials/hit");
	}

	static Mesh CreateDecalMesh()
	{
		var mesh = new Mesh ();
		mesh.vertices = new Vector3[]{
			new Vector3(-0.5f, 0, -0.5f), new Vector3(0.5f, 0, -0.5f), new Vector3(-0.5f, 0, 0.5f), new Vector3(0.5f, 0, 0.5f)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1.0f), new Vector2(1, 1.0f)
		};
		
		mesh.triangles = new int[] {
			0, 2, 1, 2, 3, 1
		};
		mesh.RecalculateBounds ();
		return mesh;
	}

	static Mesh CreateGridFloorMesh()
	{
		var mesh = new Mesh ();
		mesh.vertices = new Vector3[]{
			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(1, 0, 1)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)
		};
		mesh.colors32 = new Color32[] {
			new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255)
		};
		mesh.triangles = new int[] {
			0, 2, 1, 2, 3, 1
		};
		mesh.RecalculateBounds ();
		Bounds aabb = mesh.bounds;
		aabb.Expand(10.5f);
		mesh.bounds = aabb;
		return mesh;
	}

	static Mesh CreateGridBlockMesh1()
	{
		var mesh = new Mesh ();
		float height = 0.7f;
		float sob = 0.3f;
		mesh.vertices = new Vector3[]{
			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 0, 1), new Vector3(0, 0, 1), 
			new Vector3(sob, height, sob), new Vector3(1 - sob, height, sob), new Vector3(1 - sob, height, 1 - sob), new Vector3(sob, height, 1 - sob), 

			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 0, 1), new Vector3(0, 0, 1), 
			new Vector3(sob, height, sob), new Vector3(1 - sob, height, sob), new Vector3(1 - sob, height, 1 - sob), new Vector3(sob, height, 1 - sob), 
		};



		mesh.uv = new Vector2[]{
			new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0),
			new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0),
			new Vector2(0.5f, 0), new Vector2(0.5f, 0), new Vector2(0.5f, 0), new Vector2(0.5f, 0),
			new Vector2(0.5f, 0), new Vector2(0.5f, 0), new Vector2(0.5f, 0), new Vector2(0.5f, 0),
		};
		mesh.colors32 = new Color32[] {
			new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), 
			new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), 
			new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), new Color32(255, 255, 255, 0), 
			new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), new Color32(200, 200, 200, 255), 
		};
		mesh.triangles = new int[] {
			4, 6, 5, 4, 7, 6,
			0, 4, 5, 0, 5, 1,
			0+8, 3+8, 7+8, 0+8, 7+8, 4+8,
			1+8, 5+8, 6+8, 1+8, 6+8, 2+8
		};
		mesh.RecalculateBounds ();
		return mesh;
	}

	static Mesh CreateGridBlockMeshDark()
	{
		var mesh = CreateGridBlockMesh1 ();
		Color32[] colors = mesh.colors32;
		for (int i = 0; i< colors.Length; i++)
		{
			colors[i].a /= 2;
			colors[i].r = 200;

			//colors[i].a += 50;
		}
		mesh.colors32 = colors;
		return mesh;
	}

	static Mesh CreateGridBlockMesh()
	{
		var mesh = new Mesh ();
		mesh.vertices = new Vector3[]{
			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 0, 1), new Vector3(0, 0, 1), new Vector3(0.5f, 1.3f, 0.5f)
		};
		mesh.uv = new Vector2[]{
			new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 0), new Vector2(0, 1), new Vector2(0, 0)
		};
		mesh.colors32 = new Color32[] {
			new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(0, 0, 0, 255)
		};
		mesh.triangles = new int[] {
			0, 4, 1, 1, 4, 2, 2, 4, 3, 3, 4, 0
		};
		mesh.RecalculateBounds ();
		return mesh;
	}	

	static Mesh CreateGridBlockMeshSplit(bool bLeft)
	{
		var mesh = new Mesh ();
		float sob = 0.3f;
		float off = bLeft ? -0.25f : 0.25f;
		mesh.vertices = new Vector3[]{
			new Vector3(sob + off, 0, 0), new Vector3(1 - sob + off, 0, 0), new Vector3(1 - sob + off, 0, 1), new Vector3(sob + off, 0, 1), 
			new Vector3(0.5f + off, 1.7f, 0.5f),
			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(1, 0, 1)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0),
			new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)
		};
		mesh.colors32 = new Color32[] {
			new Color32(255, 255, 255, 50), new Color32(255, 255, 255, 50), new Color32(255, 255, 255, 50), new Color32(255, 255, 255, 50), new Color32(0, 100, 0, 255),
			new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255)
		};
		mesh.triangles = new int[] {
			0, 4, 1, 1, 4, 2, 2, 4, 3, 3, 4, 0,
			5, 7, 6, 7, 8, 6
		};
		mesh.RecalculateBounds ();
		return mesh;
	}	

	static Mesh CreateGridBlockMeshNarrow()
	{
		var mesh = new Mesh ();
		float sob = 0.4f;
		
		mesh.vertices = new Vector3[]{
			new Vector3(sob - 0.3f, 0, 0), new Vector3(1 - sob - 0.3f, 0, 0), new Vector3(1 - sob - 0.3f, 0, 1), new Vector3(sob - 0.3f, 0, 1), new Vector3(0.5f - 0.3f, 1.5f, 0.5f),
			new Vector3(sob + 0.3f, 0, 0), new Vector3(1 - sob + 0.3f, 0, 0), new Vector3(1 - sob + 0.3f, 0, 1), new Vector3(sob + 0.3f, 0, 1), new Vector3(0.5f + 0.3f, 1.5f, 0.5f),
			new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(1, 0, 1)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0),
			new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0),
			new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)
		};
		mesh.colors32 = new Color32[] {
			new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(150, 150, 150, 255),
			new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(200, 100, 50, 150), new Color32(150, 150, 150, 255),
			new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255), new Color32(255, 255, 255, 255)
		};
		mesh.triangles = new int[] {
			0, 4, 1, 1, 4, 2, 2, 4, 3, 3, 4, 0,
			0+5, 4+5, 1+5, 1+5, 4+5, 2+5, 2+5, 4+5, 3+5, 3+5, 4+5, 0+5,
			5+5, 7+5, 6+5, 7+5, 8+5, 6+5
		};
		mesh.RecalculateBounds ();
		return mesh;
	}	


	static Mesh CreateSnakeHeadMesh()
	{
		var mesh = new Mesh ();
		mesh.vertices = new Vector3[]{
			new Vector3(-0.5f, 0, -0.5f), new Vector3(0.5f, 0, -0.5f), new Vector3(-0.5f, 0, 0.5f), new Vector3(0.5f, 0, 0.5f)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0.5f), new Vector2(1, 0.5f), new Vector2(0, 1.0f), new Vector2(1, 1.0f)
		};

		mesh.triangles = new int[] {
			0, 2, 1, 2, 3, 1
		};
		mesh.RecalculateBounds ();
		return mesh;
	}

	static Mesh CreateSnakeBodyMesh()
	{
		var mesh = new Mesh ();
		mesh.vertices = new Vector3[]{
			new Vector3(-0.5f, 0, 0), new Vector3(0.5f, 0, 0), new Vector3(-0.5f, 0, 1), new Vector3(0.5f, 0, 1)
		};
		mesh.uv = new Vector2[]{
			new Vector2(0, 0.5f), new Vector2(1, 0.5f), new Vector2(0, 0), new Vector2(1, 0)
		};

		mesh.triangles = new int[] {
			0, 2, 1, 2, 3, 1
		};
		mesh.RecalculateBounds ();
		return mesh;

	}

	static int [] m_progressIndices;

	public static int[] GetProgressIndices(float p, bool inverse)
	{
		p = Mathf.Clamp01(p);
		int iSegs = m_progressIndices.Length / 3;
		int iLen = 3 * (int)(iSegs * p);
		int [] res = new int[m_progressIndices.Length];

		if (inverse) {
			for (int i = 0; i < m_progressIndices.Length; i++) {
				if (i < iLen)
					res[i] = m_progressIndices[m_progressIndices.Length - 1 - i];
				else 
					res[i] = 0;
			}
		}
		else
		{
			for (int i = 0; i < m_progressIndices.Length; i++) {
				if (i < iLen)	
					res[i] = m_progressIndices[i];
				else 
					res[i] = 0;
			}
		}
		return res;
	}

	static Mesh CreateSnakeTurnMesh()
	{
		var mesh = new Mesh ();

		int segs = 30;
		float deltaT = Mathf.PI / 2 / segs;
		Vector3[] vertices = new Vector3[segs + 2];
		Vector2[] uv = new Vector2[segs + 2];
		int[] triangles = new int[segs * 3];

		vertices[0] = new Vector3(-0.5f, 0, -0.5f);
		uv[0] = new Vector2(0, 0.5f);

		for (int i = 0; i <= segs; i++) {
			float t = deltaT * i;
			vertices[i + 1] = new Vector3(-0.5f + Mathf.Cos(t), 0, -0.5f + Mathf.Sin(t));
			uv[i + 1] = new Vector2(1, 0.5f - 0.5f * i / segs);
			if (i > 0)
			{
				triangles[i * 3 - 3 + 0] = 0;
				triangles[i * 3 - 3 + 1] = i + 1;
				triangles[i * 3 - 3 + 2] = i;
			}
		}
		mesh.vertices = vertices;
		mesh.uv = uv;
		mesh.triangles = triangles;
		mesh.RecalculateBounds ();
		return mesh;
	}

	static Mesh CreateSnakeTurnProgressMesh()
	{
		var mesh = CreateSnakeTurnMesh ();
		m_progressIndices = mesh.triangles;
		mesh.MarkDynamic();
		return mesh;
	}

	static float Ease(float f)
	{
		return -0.5f * (Mathf.Cos(Mathf.PI * f) - 1);
	}

	static Mesh CreateSnakeZoomMesh(bool bReverse)
	{
		var mesh = new Mesh ();
		
		int segs = 10;

		float deltaT = 1.0f / segs;
		float deltaV = 0.5f / segs;
		Vector3[] vertices = new Vector3[segs * 2 + 2];
		Vector2[] uv = new Vector2[segs * 2 + 2];
		int[] triangles = new int[segs * 6];
		

		for (int i = 0; i <= segs; i++) {
			float t = deltaT * i;
			vertices[i * 2] = new Vector3(-0.5f + 0.25f * Ease(t), 0, bReverse ? 1 - t : t);
			uv[i * 2] = new Vector2(0, 0.5f - deltaV * i);
			vertices[i * 2 + 1] = new Vector3(0.5f - 0.25f * Ease(t), 0, bReverse ? 1 - t : t);
				uv[i * 2 + 1] = new Vector2(1, 0.5f - deltaV * i);
			if (i > 0)
			{
				int start = i * 6 - 6;
				triangles[start + 0] = i * 2 + 0 - 2;
				triangles[start + 1] = i * 2 + 1 - 2;
				triangles[start + 2] = i * 2 + 3 - 2;
				triangles[start + 3] = i * 2 + 0 - 2;
				triangles[start + 4] = i * 2 + 3 - 2;
				triangles[start + 5] = i * 2 + 2 - 2;
			}
		}
		mesh.vertices = vertices;
		mesh.uv = uv;
		mesh.triangles = triangles;
		mesh.RecalculateBounds ();
		return mesh;
	}

	static Mesh CreateSnakeSplitMesh(bool bReverse, bool bLeft)
	{
		var mesh = new Mesh ();
		
		int segs = 10;
		
		float deltaT = 1.0f / segs;
		float deltaV = 0.5f / segs;
		Vector3[] vertices = new Vector3[segs * 2 + 2];
		Vector2[] uv = new Vector2[segs * 2 + 2];
		int[] triangles = new int[segs * 6];
		
		
		for (int i = 0; i <= segs; i++) {
			float t = deltaT * i;
			float fLeft = bLeft ? -0.5f : -0.5f + 0.5f * Ease(t);
			float fRight = !bLeft ? 0.5f : 0.5f - 0.5f * Ease(t);

			vertices[i * 2] = new Vector3(fLeft, 0, bReverse ? 1 - t : t);
			vertices[i * 2 + 1] = new Vector3(fRight, 0, bReverse ? 1 - t : t);

			uv[i * 2] = new Vector2(0, 0.5f - deltaV * i);
			uv[i * 2 + 1] = new Vector2(1, 0.5f - deltaV * i);
			if (i > 0)
			{
				int start = i * 6 - 6;
				triangles[start + 0] = i * 2 + 0 - 2;
				triangles[start + 1] = i * 2 + 1 - 2;
				triangles[start + 2] = i * 2 + 3 - 2;
				triangles[start + 3] = i * 2 + 0 - 2;
				triangles[start + 4] = i * 2 + 3 - 2;
				triangles[start + 5] = i * 2 + 2 - 2;
			}
		}
		mesh.vertices = vertices;
		mesh.uv = uv;
		mesh.triangles = triangles;
		mesh.RecalculateBounds ();
		return mesh;
	}

	public static GameObject CreateGridObject(Vector3 pos, int iType)
	{
		GameObject gameObj;

		if (m_freeObjects.Count > 0) {
			gameObj = m_freeObjects [m_freeObjects.Count - 1];
			m_freeObjects.RemoveAt (m_freeObjects.Count - 1);
		} else {
			string strTag = iType.ToString();
			gameObj = new GameObject (strTag);
			gameObj.AddComponent<MeshFilter> ();
			gameObj.AddComponent<MeshRenderer> ();
		}
		gameObj.GetComponent<MeshFilter> ().sharedMesh = m_gridMesh[iType];;
		gameObj.GetComponent<MeshRenderer> ().sharedMaterial = m_gridMaterial[iType];;
		
		gameObj.transform.position = pos;
		gameObj.transform.eulerAngles = Vector3.zero;
		gameObj.transform.localScale = Vector3.one;
		gameObj.transform.rotation = Quaternion.AngleAxis(0, Vector3.up);
		gameObj.SetActive (true);

		return gameObj;
	}

	public static void ReturnGridObject(GameObject obj) {
		if (obj == null)
			return;

//		for (int i = 0; i < m_freeGrid[iType].Count; i++)
//			if (obj == m_freeGrid[iType][i])
//				Debug.LogError("Dup!");
		m_freeObjects.Add (obj);
		obj.SetActive (false);
	}

	public static GameObject CreateDecalObject(Vector3 pos, int iType)
	{
		GameObject gameObj;
		if (m_freeObjects.Count > 0) {
			gameObj = m_freeObjects[m_freeObjects.Count - 1];
			m_freeObjects.RemoveAt (m_freeObjects.Count - 1);
		} else {
			string strTag = iType.ToString();
			gameObj = new GameObject (strTag);
			gameObj.AddComponent<MeshFilter> ();
			gameObj.AddComponent<MeshRenderer> ();
		}
		gameObj.GetComponent<MeshFilter> ().sharedMesh = m_decalMesh;
		gameObj.GetComponent<MeshRenderer> ().sharedMaterial = m_decalMaterial[iType];
		gameObj.transform.position = pos;
		gameObj.transform.eulerAngles = Vector3.zero;
		gameObj.transform.localScale = Vector3.one;
		gameObj.transform.rotation = Quaternion.AngleAxis(0, Vector3.up);
		gameObj.SetActive (true);
		
		return gameObj;
	}
	
	public static void ReturnDecalObject(GameObject obj) {
		if (obj == null)
			return;
		//		for (int i = 0; i < m_freeGrid[iType].Count; i++)
		//			if (obj == m_freeGrid[iType][i])
		//				Debug.LogError("Dup!");
		m_freeObjects.Add (obj);
		obj.SetActive (false);
	}

}


